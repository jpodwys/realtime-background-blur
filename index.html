<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Realtime Background Blurring Demo</title>
    <style>
      body {
        background-color: black;
        color: white;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Realtime Background Blurring Demo</h1>
      <button id="toggle">Toggle Blur</button>
    </header>

    <main>
      <video id="video-input" autoplay></video>
      <canvas id="video-output"></canvas>
    </main>

    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/body-pix@2.0"></script>
    <script>
      class Blur {
        constructor () {
          this.blur = true;
          this.startDraw = performance.now();
          this.totalFrames = 0;

          this.bodyPixConfig = {
            architechture: 'ResNetV1',
            outputStride: 16,
            multiplier: 1,
            quantBytes: 4
          };

          this.segmentationConfig = {
            internalResolution: 1,
            segmentationThreshold: 0.5,
            scoreThreshold: 1
          };
        }

        async init () {
          this.videoInput = document.getElementById('video-input');
          this.processCanvas = document.createElement('canvas');
          this.processCtx = this.processCanvas.getContext('2d');
          this.blurCanvas = document.createElement('canvas');
          this.blurCtx = this.blurCanvas.getContext('2d');
          this.outputCanvas = document.getElementById('video-output');
          this.outputCtx = this.outputCanvas.getContext('2d');

          this.model = await bodyPix.load(this.bodyPixConfig);
          this.initVideoStream();
        }

        toggle () {
          this.blur = !this.blur;

          if (this.blur) {
            this.startDraw = performance.now();
          } else {
            const elapsed = (performance.now() - this.startDraw) / 1000;
            console.log('Average FPS:', this.totalFrames / elapsed);
            this.totalFrames = 0;
          }
        }

        async initVideoStream () {
          const stream = await navigator.mediaDevices.getUserMedia({ video: true });
          this.videoInput.addEventListener('loadedmetadata', () => {
            this.width = this.videoInput.videoWidth;
            this.height = this.videoInput.videoHeight;
            this.setElementProperties();
            this.draw();
          });
          this.videoInput.srcObject = stream;
        }

        setElementProperties () {
          this.setCanvasWidth(this.processCanvas);
          this.setCanvasWidth(this.blurCanvas);
          this.setCanvasWidth(this.outputCanvas);

          this.blurCtx.filter = 'blur(15px)';
        }

        setCanvasWidth (canvas) {
          canvas.width = this.width
          canvas.height = this.height
        }

        async draw () {
          if (!this.blur) {
            this.outputCtx.drawImage(this.videoInput, 0, 0, this.width, this.height);
            setTimeout(this.draw.bind(this), 1000 / 30);
          } else {
            // Todo: Move this into a worker thread that uses OffscreenCanvas
            this.processCtx.drawImage(this.videoInput, 0, 0, this.width, this.height);
            const segmentation = await this.model.segmentPerson(this.processCanvas);
            bodyPix.drawBokehEffect(this.outputCanvas, this.processCanvas, segmentation, 5, 3);
            this.totalFrames++;
            await this.draw();
          }
        }
      }

      const blur = new Blur();
      blur.init();

      document.getElementById('toggle').addEventListener('click', () => {
        blur.toggle();
      });
    </script>
  </body>
</html>
